/*
  assembler.h  Headerfile for assembler.c
  Copyright (C) 2019 Patrick GÃ¼nthard

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */
#ifndef ASSEMBLER_H
#define ASSEMBLER_H

#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
/*
Address Modes:

A		....	Accumulator	 	OPC A	 	operand is AC (implied single byte instruction)
abs		....	absolute	 	OPC $LLHH	 	operand is address $HHLL *
abs,X		....	absolute, X-indexed	OPC $LLHH,X	 	operand is address; effective address is address incremented by X with carry **
abs,Y		....	absolute, Y-indexed	OPC $LLHH,Y	 	operand is address; effective address is address incremented by Y with carry **
#		....	immediate	 	OPC #$BB	 	operand is byte BB
impl		....	implied	 		OPC	 	operand implied
ind		....	indirect	 	OPC ($LLHH)	 	operand is address; effective address is contents of word at address: C.w($HHLL)
X,ind		....	X-indexed, indirect	OPC ($LL,X)	 	operand is zeropage address; effective address is word in (LL + X, LL + X + 1), inc. without carry: C.w($00LL + X)
ind,Y		....	indirect, Y-indexed	OPC ($LL),Y	 	operand is zeropage address; effective address is word in (LL, LL + 1) incremented by Y with carry: C.w($00LL) + Y
rel		....	relative	 	OPC $BB	 	branch target is PC + signed offset BB ***
zpg		....	zeropage	 	OPC $LL	 	operand is zeropage address (hi-byte is zero, address = $00LL)
zpg,X		....	zeropage, X-indexed	OPC $LL,X	 	operand is zeropage address; effective address is address incremented by X without carry **
zpg,Y		....	zeropage, Y-indexed	OPC $LL,Y	 	operand is zeropage address; effective address is address incremented by Y without carry **
*/

enum e_line_type
{
  operation = 0,
  op_with_label = 1,
  lbl = 2,
  pseudoop = 3,
  skip = 4,
  def = 5
};

typedef enum e_line_type line_type;

enum e_addressing_mode
{
  absolute = 0,
  absolute_x = 1,
  absolute_y = 2,
  immediate = 3,
  implied = 4, // in impled mode no address is given
  indirect = 5,
  indirect_x = 6,
  indirect_y = 7,
  relative = 8,
  zeropage = 9,
  zeropage_x = 10,
  zeropage_y = 11,
  accumlator = 12
};

typedef enum e_addressing_mode addressing_mode;

struct s_addressing_information
{
  addressing_mode mode;
  uint8_t lbyte;
  uint8_t hbyte;
};

typedef struct s_addressing_information addressing_information;

struct s_opcode
{
  uint8_t code;
  size_t bytes;
};

typedef struct s_opcode opcode;

struct s_label
{
  char labelname[32];
  uint16_t pc;
  size_t size;
  bool rel;
};

typedef struct s_label label;

addressing_information calc_addressing_information(char[], bool);

size_t construct_binopt(char[], uint8_t **, bool);

uint16_t parse_number(char[], addressing_mode);

line_type get_line_type(char line[]);

void add_label(char *, uint16_t, bool);

char *add_label_reference(char *, uint16_t);

char *remove_comment(char *);

static char opcode_label_table[56][4] =
    {
        "ADC",
        "AND",
        "ASL",
        "BCC",
        "BCS",
        "BEQ",
        "BIT",
        "BMI",
        "BNE",
        "BPL",
        "BRK",
        "BVC",
        "BVS",
        "CLC",
        "CLD",
        "CLI",

        "CLV",
        "CMP",
        "CPX",
        "CPY",
        "DEC",
        "DEX",
        "DEY",
        "EOR",
        "INC",
        "INX",
        "INY",
        "JMP",
        "JSR",
        "LDA",
        "LDX",
        "LDY",

        "LSR",
        "NOP",
        "ORA",
        "PHA",
        "PHP",
        "PLA",
        "PLP",
        "ROL",
        "ROR",
        "RTI",
        "RTS",
        "SBC",
        "SEC",
        "SED",
        "SEI",
        "STA",

        "STX",
        "STY",
        "TAX",
        "TAY",
        "TSX",
        "TXA",
        "TXS",
        "TYA"};

static uint8_t opcode_table[56][13] =
  {
 /* abs   absx  absy  imm   impl  ind   indx  indy  rel   zpg   zpgx  zpgy  acc*/
   {0x6d, 0x7d, 0x79, 0x69, 0x00, 0x00, 0x61, 0x71, 0x00, 0x65, 0x75, 0x00, 0x00}, // ADC
   {0x2d, 0x3d, 0x39, 0x29, 0x00, 0x00, 0x21, 0x31, 0x00, 0x25, 0x35, 0x00, 0x00}, // AND
   {0x0e, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x16, 0x00, 0x00}, // ASL
   {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 0x00}, // BCC
   {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb0, 0x00, 0x00, 0x00, 0x00}, // BCS
   {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00}, // BEQ
   {0x2c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00}, // BIT
   {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00}, // BMI
   {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd0, 0x00, 0x00, 0x00, 0x00}, // BNE
   {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00}, // BPL
   {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // BRK
   {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00}, // BVC
   {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00}, // BVS
   {0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // CLC
   {0x00, 0x00, 0x00, 0x00, 0xd9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // CLD
   {0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // CLI
   
 /* abs   absx  absy  imm   impl  ind   indx  indy  rel   zpg   zpgx  zpgy  acc*/
   {0x00, 0x00, 0x00, 0x00, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // CLV
   {0xcd, 0xdd, 0xd9, 0xc9, 0x00, 0x00, 0xc1, 0xd1, 0x00, 0xc5, 0xd5, 0x00, 0x00}, // CMP
   {0xec, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe4, 0x00, 0x00, 0x00}, // CPX
   {0xcc, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc4, 0x00, 0x00, 0x00}, // CPY
   {0xce, 0xde, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc6, 0xd6, 0x00, 0x00}, // DEC
   {0x00, 0x00, 0x00, 0x00, 0xca, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // DEX
   {0x00, 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // DEY   
   {0x4d, 0x5d, 0x59, 0x49, 0x00, 0x00, 0x41, 0x51, 0x00, 0x45, 0x55, 0x00, 0x00}, // EOR
   {0xee, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0xf6, 0x00, 0x00}, // INC
   {0x00, 0x00, 0x00, 0x00, 0xe8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // INX
   {0x00, 0x00, 0x00, 0x00, 0xc8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // INY
   {0x4c, 0x00, 0x00, 0x00, 0x00, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // JMP
   {0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // JSR
   {0xad, 0xbd, 0xb9, 0xa9, 0x00, 0x00, 0xa1, 0xb1, 0x00, 0xa5, 0xb5, 0x00, 0x00}, // LDA
   {0xae, 0x00, 0xbe, 0xa2, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa6, 0x00, 0xbe, 0x00}, // LDX
   {0xac, 0xbc, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb4, 0xb5, 0x00, 0x00}, // LDY
 /* abs   absx  absy  imm   impl  ind   indx  indy  rel   zpg   zpgx  zpgy  acc*/

   {0x4e, 0x5e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x56, 0x00, 0x4a}, // LSR
   {0x00, 0x00, 0x00, 0x00, 0xea, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // NOP
   {0x0d, 0x1d, 0x19, 0x09, 0x00, 0x00, 0x01, 0x11, 0x00, 0x05, 0x15, 0x00, 0x00}, // ORA
   {0x00, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // PHA
   {0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // PHP
   {0x00, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // PLA
   {0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // PLP
   {0x2e, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x36, 0x00, 0x2a}, // ROL
   {0x6e, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x76, 0x00, 0x6a}, // ROR
   {0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // RTI
   {0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // RTS
   {0xed, 0xfd, 0xf9, 0xe9, 0x00, 0x00, 0xe1, 0xf1, 0x00, 0xe5, 0xf5, 0x00, 0x00}, // SBC
   {0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // SEC
   {0x00, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // SED
   {0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // SEI
   {0x8d, 0x9d, 0x99, 0x00, 0x00, 0x00, 0x81, 0x91, 0x00, 0x85, 0x95, 0x00, 0x00}, // STA
 /* abs   absx  absy  imm   impl  ind   indx  indy  rel   zpg   zpgx  zpgy  acc*/

   {0x8c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x86, 0x00, 0x96, 0x00}, // STX
   {0x8e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0x94, 0x00, 0x00}, // STY
   {0x00, 0x00, 0x00, 0x00, 0xaa, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // TAX
   {0x00, 0x00, 0x00, 0x00, 0xa8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // TAY
   {0x00, 0x00, 0x00, 0x00, 0xba, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // TSX
   {0x00, 0x00, 0x00, 0x00, 0x8a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // TXA
   {0x00, 0x00, 0x00, 0x00, 0x9a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // TXS
   {0x00, 0x00, 0x00, 0x00, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} // TYA
   
 /* abs   absx  absy  imm   impl  ind   indx  indy  rel   zpg   zpgx  zpgy  acc*/
  };

static char implied_ops[26][4] = {"BRK", "RTI", "RTS", "PHP", "CLC", "PLP", "SEC", "PHA", "CLI", "PLA", "SEI", "DEY", "TYA", "TAY", "CLV", "INY", "CLD", "INX", "SED", "TXA", "TXS", "TAX", "TSX", "DEX", "NOP"};
static int implied_ops_count = 26;

bool is_implied_addr_op(char *);

static char accum_ops[4][4] = {"ASL", "ROL", "LSR", "ROR"};
static int accum_ops_count = 4;

bool is_accum_addr_op(char *);

static char relative_ops[8][4] = {"BPL", "BMI", "BVC", "BVS", "BCC", "BCS", "BNE", "BEQ"};
static int relative_ops_count = 8;

bool is_relative_addr_op(char *);

static char force_word_ops[2][4] = {"JMP", "JSR"};
static int force_word_ops_count = 2;

bool is_force_word_op(char *);

/*                                abs abx aby imm imp ind inx iny rel zpg zpx zpy acc*/
static int op_address_size[13] = {3,  3,  3,  2,  1,  3,  2,  2,  2,  2,  2,  2,  1};

static char pseudo_ops[3][6] = {".pc", ".byte", ".word"};
static int pseudo_ops_size = 3;

#endif
